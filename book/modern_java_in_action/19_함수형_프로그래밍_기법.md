# í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ê¸°ë²•

# í•¨ìˆ˜ëŠ” ëª¨ë“  ê³³ì— ì¡´ì¬í•œë‹¤

- `ì¼ê¸‰ í•¨ìˆ˜(first class function)` : ì¼ë°˜ ê°’ì²˜ëŸ¼ ì·¨ê¸‰í•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜
- ìë°” 8 : ì¼ê¸‰ í•¨ìˆ˜ë¥¼ ì§€ì›í•œë‹¤
  - ë©”ì„œë“œ ì°¸ì¡°
  - ëŒë‹¤ í‘œí˜„ì‹

```java
Function<String, Integer> strToInt = Integer::parseInt;
```

## ê³ ì°¨ì› í•¨ìˆ˜(higher-order functions)

- ë‹¤ìŒ ì¤‘ í•˜ë‚˜ ì´ìƒì˜ ë™ì‘ì„ ìˆ˜í–‰í•˜ëŠ” í•¨ìˆ˜
  - í•˜ë‚˜ ì´ìƒì˜ í•¨ìˆ˜ë¥¼ ì¸ìˆ˜ë¡œ ë°›ìŒ
  - í•¨ìˆ˜ë¥¼ ê²°ê³¼ë¡œ ë°˜í™˜
- êµ¬í˜„í•  ë•Œ ì–´ë–¤ ì¸ìˆ˜ê°€ ì „ë‹¬ë ì§€ ì•Œ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì¸ìˆ˜ê°€ ë¶€ì‘ìš©ì„ í¬í•¨í•  ê°€ëŠ¥ì„±ì„ ì—¼ë‘ì— ë‘ì–´ì•¼ í•œë‹¤

## ì»¤ë§(currying)

- í•¨ìˆ˜ë¥¼ ëª¨ë“ˆí™”í•˜ê³  ì½”ë“œë¥¼ ì¬ì‚¬ìš©í•˜ëŠ” ë° ë„ì›€ì„ ì£¼ëŠ” ê¸°ë²•
- xì™€ yë¼ëŠ” ë‘ ì¸ìˆ˜ë¥¼ ë°›ëŠ” í•¨ìˆ˜ fë¥¼ í•œ ê°œì˜ ì¸ìˆ˜ë¥¼ ë°›ëŠ” gë¼ëŠ” í•¨ìˆ˜ë¡œ ëŒ€ì²´í•˜ëŠ” ê¸°ë²•
  - gë„ í•˜ë‚˜ì˜ ì¸ìˆ˜ë¥¼ ë°›ëŠ” í•¨ìˆ˜ë¥¼ ë°˜í™˜
- ê¸°ì¡´ ë¡œì§ì„ í™œìš©í•´ì„œ ë³€í™˜ê¸°ë¥¼ íŠ¹ì • ìƒí™©ì— ì ìš©
  - ë¡œì§ì„ ì¬í™œìš©í•˜ëŠ” ìœ ì—°í•œ ì½”ë“œë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŒ

```java
static DoubleUnaryOperator curriedConverter(double f, double b) {
    return (double x) -> x * f + b;
}

DoubleUnaryOperator convertCtoF = curriedConverter(9.0 / 5, 32);

// convertCtoFëŠ” ì•„ë˜ converter í•¨ìˆ˜ì™€ ë™ì¼
static double converter(double x) {
    return x * 9.0 / 5 + 32
}

// ë‹¤ìŒê³¼ ê°™ì´ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
double fahrenheit = convertCtoF.applyAsDouble(36); // ì¸ìˆ˜ x
```

# ì˜ì† ìë£Œêµ¬ì¡°

- í•¨ìˆ˜í˜• í”„ë¡œê·¸ë¨ì—ì„œ ì‚¬ìš©í•˜ëŠ” ìë£Œêµ¬ì¡°

## íŒŒê´´ì ì¸ ê°±ì‹ ê³¼ í•¨ìˆ˜í˜•

```java
public class TrainJourney {
    public int price;
    public TrainJourney onward; // ë‹¤ìŒ í–‰ì„ ì§€

    public TrainJourney(int price, TrainJourney onward) {
        this.price = price;
        this.onward = onward;
    }
}
```

```java
// ë§ˆì§€ë§‰ ì—¬ì •ì„ ì°¾ì•„(ë§ˆì§€ë§‰ ì—¬ì •ì˜ onward == null) secondJourneyë¡œ ëŒ€ì²´
public static TrainJourney link(TrainJourney firstJourney, TrainJourney secondJourney) {
    if (firstJourney == null) {
        return secondJourney;
    }
    TrainJourney t = firstJourney;
    while (t.onward != null) {
        t = t.onward;
    }
    t.onward = secondJourney;
    return firstJourney;
}
// ìë£Œêµ¬ì¡°ê°€ ë°”ë€Œê²Œ ë¨
```

- í•¨ìˆ˜í˜•ì—ì„œëŠ” ë¶€ì‘ìš©ì„ ìˆ˜ë°˜í•˜ëŠ” ë©”ì„œë“œë¥¼ ì œí•œí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë¬¸ì œ í•´ê²°
  - ê¸°ì¡´ì˜ ìë£Œêµ¬ì¡°ë¥¼ ê°±ì‹ í•˜ì§€ ì•Šë„ë¡ ìƒˆë¡œìš´ ìë£Œêµ¬ì¡°ë¥¼ ë§Œë“¤ì–´ì•¼ í•¨

```java
public static TrainJourney append(TrainJourney firstJourney, TrainJourney secondJourney) {
    return firstJourney == null
            ? secondJourney
            : new TrainJourney(firstJourney.price, append(firstJourney.onward, secondJourney));
}
// ê¸°ì¡´ ìë£Œêµ¬ì¡°ë¥¼ ë³€ê²½í•˜ì§€ ì•ŠìŒ
```

## íŠ¸ë¦¬ë¥¼ ì‚¬ìš©í•œ ì˜ˆì œ

```java
public class Tree {
    public String key;
    public int val;
    public Tree left, right;

    public Tree(String key, int val, Tree left, Tree right) {
        this.key = key;
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

```java
public class TreeProcessor {
    public static int lookup(String key, int defaultVal, Tree tree) {
        if (tree == null) {
            return defaultVal;
        }
        if (key.equals(tree.key)) {
            return tree.val;
        }
        return lookup(key, defaultVal,
                key.compareTo(tree.key) < 0 ? tree.left : tree.right);
        // ê²€ìƒ‰í•˜ë ¤ëŠ” keyê°€ treeì˜ keyë³´ë‹¤ ì‘ìœ¼ë©´ ì™¼ìª½
        // í¬ë©´ ì˜¤ë¥¸ìª½
    }
}
```

```java
public static void update(String key, int newVal, Tree tree) {
    // value ì—…ë°ì´íŠ¸
    if (tree == null) {
        // ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ì¶”ê°€
    } else if (key.equals(tree.key)) {
        tree.val = newVal;
    } else {
        update(key, newVal,
                key.compareTo(tree.key) < 0 ? tree.left : tree.right);
    }
}

public static void update2(String key, int newVal, Tree tree) {
    if (tree == null) {
        tree = new Tree(key, newVal, null, null);
    } else if (key.equals(tree.key)) {
        tree.val = newVal;
    } else if (key.compareTo(tree.key) < 0) {
        update(key, newVal, tree.left);
    } else {
        update(key, newVal, tree.right);
    }
}
```

- ë‘ ë²„ì „ ëª¨ë‘ ê¸°ì¡´ íŠ¸ë¦¬ ë³€ê²½

## í•¨ìˆ˜í˜• ì ‘ê·¼ë²• ì‚¬ìš©

- ìƒˆë¡œìš´ ë…¸ë“œë“¤ ë§Œë“¤ê¸°

```java
public static Tree updateFunctional(String key, int newVal, Tree tree) {
    if (tree == null) {
        return new Tree(key, newVal, null, null);
    }
    if (key.equals(tree.key)) {
        return new Tree(key, newVal, tree.left, tree.right);
        // valueë§Œ ë³€ê²½ëœ ìƒˆë¡œìš´ tree ë§Œë“¤ê¸°
    }
    if (key.compareTo(tree.key) < 0) {
        return new Tree(tree.key, tree.val, updateFunctional(key, newVal, tree.left), tree.right);
    }
    return new Tree(tree.key, tree.val, tree.left, updateFunctional(key, newVal, tree.right));
}
```

- ì¸ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ ê°€ëŠ¥í•œ í•œ ë§ì€ ì •ë³´ë¥¼ ê³µìœ 
- ê¸°ì¡´ì˜ íŠ¸ë¦¬ë¥¼ ê°±ì‹ í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ë§Œë“¦
- `ì˜ì†(persistent)` : ì €ì¥ëœ ê°’ì´ ë‹¤ë¥¸ ëˆ„êµ°ê°€ì— ì˜í•´ ì˜í–¥ì„ ë°›ì§€ ì•ŠëŠ” ìƒíƒœ
- ê¸°ì¡´ ìë£Œ êµ¬ì¡°ì—ëŠ” ì•„ë¬´ëŸ° ì˜í–¥ë„ ë¯¸ì¹˜ì§€ ì•ŠìŒ

# ìŠ¤íŠ¸ë¦¼ê³¼ ê²Œìœ¼ë¥¸ í‰ê°€

- ìŠ¤íŠ¸ë¦¼ì€ ë‹¨ í•œ ë²ˆë§Œ ì†Œë¹„í•  ìˆ˜ ìˆë‹¤ â¡ï¸ ì¬ê·€ì ìœ¼ë¡œ ì •ì˜í•  ìˆ˜ ì—†ë‹¤

```java
public static Stream<Integer> primes(int n) {
    return Stream.iterate(2, i -> i + 1)
            .filter(PrimeTest::isPrime)
            .limit(n); // 2ë¶€í„° ì‹œì‘í•´ì„œ ì†Œìˆ˜ nê°œ ë¦¬í„´
}

public static boolean isPrime(int candidate) {
    int candidateRoot = (int) Math.sqrt((double) candidate); // ì œê³±ê·¼ ì°¾ê¸°
    return IntStream.rangeClosed(2, candidateRoot)
            .noneMatch(i -> candidate % i == 0);
}
```

- ë§¤ë²ˆ ëª¨ë“  ìˆ˜ë¥¼ ë°˜ë³µí•´ì„œ í›„ë³´ ìˆ˜ë¡œ ë‚˜ëˆ„ì–´ë–¨ì–´ì§€ëŠ”ì§€ í™•ì¸í•´ì•¼ í•¨
- ì†Œìˆ˜ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆëŠ” ëª¨ë“  ìˆ˜ëŠ” ì œì™¸í•  ìˆ˜ ìˆìŒ

## ì¬ê·€ì ìœ¼ë¡œ ì†Œìˆ˜ ìŠ¤íŠ¸ë¦¼ ìƒì„±í•˜ê¸°

```java
// 1. ìŠ¤íŠ¸ë¦¼ ìˆ«ì ì–»ê¸°
public static IntStream numbers() {
    return IntStream.iterate(2, n -> n + 1);
}

// 2. ë¨¸ë¦¬ íšë“
public static int head(IntStream numbers) {
    return numbers.findFirst()
            .getAsInt();
}

// 3. ê¼¬ë¦¬ í•„í„°ë§
public static IntStream tail(IntStream numbers) {
    return numbers.skip(1); // ì²˜ìŒ í•œ ê°œë¥¼ ê±´ë„ˆ ë›°ê³  ìƒˆë¡œìš´ IntStream ìƒì„±
}

// 4. ì¬ê·€ì ìœ¼ë¡œ ì†Œìˆ˜ ìŠ¤íŠ¸ë¦¼ ìƒì„±
public static IntStream primes(IntStream numbers) {
    int head = head(numbers);
    return IntStream.concat(
            IntStream.of(head),
            primes(tail(numbers).filter(n -> n % head != 0))
    );
}
```

- â¡ï¸ `IllegalStateException` ë°œìƒ

### ê²Œìœ¼ë¥¸ í‰ê°€

- ìë°”ì—ì„œëŠ” ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©´ ëª¨ë“  ì¸ìˆ˜ê°€ ì¦‰ì‹œ í‰ê°€ë¨
- IntStream.concatì€ ë‘ ê°œì˜ ìŠ¤íŠ¸ë¦¼ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì¸ìˆ˜ë¡œ ë°›ìŒ
- ë‘ ë²ˆì§¸ ì¸ìˆ˜ê°€ primesë¥¼ ì§ì ‘ ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œ â¡ï¸ ë¬´í•œ ì¬ê·€ì— ë¹ ì§
- â¡ï¸ ì†Œìˆ˜ë¥¼ ì²˜ë¦¬í•  í•„ìš”ê°€ ìˆì„ ë•Œë§Œ ìŠ¤íŠ¸ë¦¼ì„ ì‹¤ì œë¡œ í‰ê°€í•˜ëŠ” `ê²Œìœ¼ë¥¸ í‰ê°€`ë¡œ í•´ê²°í•  ìˆ˜ ìˆìŒ

## ê²Œìœ¼ë¥¸ ë¦¬ìŠ¤íŠ¸ ë§Œë“¤ê¸°

- ìë°” 8ì˜ ìŠ¤íŠ¸ë¦¼ì€ ê²Œìœ¼ë¥´ë‹¤
  - ìŠ¤íŠ¸ë¦¼ì— ì¼ë ¨ì˜ ì—°ì‚°ì„ ì ìš©í•˜ë©´ ì—°ì‚°ì´ ìˆ˜í–‰ë˜ì§€ ì•Šê³  ì¼ë‹¨ ì €ì¥ëœë‹¤
  - ìµœì¢… ì—°ì‚°ì„ ì ìš©í•´ì„œ ì‹¤ì œ ê³„ì‚°ì„ í•´ì•¼ í•˜ëŠ” ìƒí™©ì—ì„œë§Œ ì‹¤ì œ ì—°ì‚°ì´ ì´ë£¨ì–´ì§„ë‹¤
  - ê° ì—°ì‚°ë³„ë¡œ ìŠ¤íŠ¸ë¦¼ì„ íƒìƒ‰í•  í•„ìš” ì—†ì´ í•œ ë²ˆì— ì—¬ëŸ¬ ì—°ì‚°ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤
- ê²Œìœ¼ë¥¸ ë¦¬ìŠ¤íŠ¸ ê³ ì°¨ì› í•¨ìˆ˜ ê°œë… ì§€ì›
  - í•¨ìˆ«ê°’ì„ ìë£Œêµ¬ì¡°ì— ì €ì¥í•´ì„œ ì‚¬ìš©í•˜ì§€ ì•Šì€ ìƒíƒœë¡œ ë³´ê´€í•  ìˆ˜ ìˆë‹¤
  - ì €ì¥í•œ í•¨ìˆ«ê°’ì„ í˜¸ì¶œí•˜ë©´ ë” ë§ì€ ìë£Œêµ¬ì¡°ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤
- ê²Œìœ¼ë¥¸ ë¦¬ìŠ¤íŠ¸ëŠ” ìë°” ìŠ¤íŠ¸ë¦¼ë³´ë‹¤ ë¹„ì‹¼ ë²„ì „

### ê¸°ë³¸ì ì¸ ì—°ê²° ë¦¬ìŠ¤íŠ¸

```java
public interface MyList<T> {
    T head();
    MyList<T> tail();

    default boolean isEmpty() {
        return true;
    }
}
```

```java
public class MyLinkedList<T> implements MyList<T> {
    private final T head;
    private final MyList<T> tail;

    public MyLinkedList(T head, MyList<T> tail) {
        this.head = head;
        this.tail = tail;
    }

    @Override
    public T head() {
        return head;
    }

    @Override
    public MyList<T> tail() {
        return tail;
    }

    @Override
    public boolean isEmpty() {
        return false;
    }
}
```

```java
public class Empty<T> implements MyList<T> {
    @Override
    public T head() {
        throw new UnsupportedOperationException();
    }

    @Override
    public MyList<T> tail() {
        throw new UnsupportedOperationException();
    }
}
```

```java
MyList<Integer> list = new MyLinkedList<>(5, new MyLinkedList<>(10, new Empty<>()));
```

### ê¸°ë³¸ì ì¸ ê²Œìœ¼ë¥¸ ë¦¬ìŠ¤íŠ¸

- Supplier\<T>ë¥¼ ì´ìš©í•´ì„œ ê²Œìœ¼ë¥¸ ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ë©´ ê¼¬ë¦¬ê°€ ëª¨ë‘ ë©”ëª¨ë¦¬ì— ì¡´ì¬í•˜ì§€ ì•Šê²Œ í•  ìˆ˜ ìˆìŒ
  - SUpplier\<T>ë¡œ ë¦¬ìŠ¤íŠ¸ì˜ ë‹¤ìŒ ë…¸ë“œ ìƒì„±(ìë£Œêµ¬ì¡° ìš”ì†Œ ìƒì„±í•˜ëŠ” ì—­í• )

```java
public class LazyList<T> implements MyList<T> {
    final T head;
    final Supplier<MyList<T>> tail;

    private LazyList(T head, Supplier<MyList<T>> tail) {
        this.head = head;
        this.tail = tail;
    }

    public static LazyList<Integer> from(int n) {
        return new LazyList<>(n, () -> from(n + 1));
    }

    @Override
    public T head() {
        return head;
    }

    @Override
    public MyList<T> tail() {
        return tail.get(); // Supplierë¡œ ê²Œìœ¼ë¥¸ ë™ì‘
    }

    @Override
    public boolean isEmpty() {
        return false;
    }
}
```

```java
LazyList<Integer> numbers = LazyList.from(2);
int two = numbers.head();
int three = numbers.tail().head();
int four = numbers.tail().tail().head();
```

### ê²Œìœ¼ë¥¸ í•„í„° êµ¬í˜„

```java
@Override
public MyList<T> filter(Predicate<T> p) {
    if (isEmpty()) {
        return this;
    }
    if (p.test(head())) {
        return new LazyList<>(head(), () -> tail().filter(p));
    }
    return tail().filter(p);
}
```

- ì†Œìˆ˜ ìƒì„± ì½”ë“œ

```java
public static MyList<Integer> primes(MyList<Integer> numbers) {
    return new LazyList<>(
            numbers.head(),
            () -> primes(
                    numbers.tail()
                            .filter(n -> n % numbers.head() != 0)
            )
    );
}
```

```java
LazyList<Integer> numbers = LazyList.from(2);
int two = primes(numbers).head();
int three = primes(numbers).tail().head();
int five = primes(numbers).tail().tail().head();
```

- ìë£Œêµ¬ì¡°ì˜ 10í¼ì„¼íŠ¸ ë¯¸ë§Œì˜ ë°ì´í„°ë§Œ í™œìš©í•˜ëŠ” ìƒí™©ì—ì„œëŠ” ê²Œìœ¼ë¥¸ ì‹¤í–‰ìœ¼ë¡œ ì¸í•œ ì˜¤ë²„ í—¤ë“œê°€ ë” ì»¤ì§ˆ ìˆ˜ ìˆë‹¤

# íŒ¨í„´ ë§¤ì¹­

- ìë£Œí˜•ì„ ì–¸ë©í•˜ëŠ” í•¨ìˆ˜í˜• ê¸°ëŠ¥

## ë°©ë¬¸ì ë””ìì¸ íŒ¨í„´(visitor design pattern)

- íŠ¹ì • ë°ì´í„° í˜•ì‹ì„ 'ë°©ë¬¸'í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì„ ìº¡ìŠí™”í•˜ëŠ” í´ë˜ìŠ¤ë¥¼ ë”°ë¡œ ë§Œë“¤ ìˆ˜ ìˆë‹¤
- ê°ì²´ êµ¬ì¡°ë¥¼ ë³€ê²½í•˜ì§€ ì•Šê³  ìƒˆë¡œìš´ ë™ì‘ì„ ì¶”ê°€

```java
public interface Animal {
    void accept(Visitor visitor);
}

public class Dog implements Animal {
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    void bark() {
        System.out.println("ë©ë©");
    }

    void emoji() {
        System.out.println("ğŸ¶");
    }
}

public class Cat implements Animal {
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    void meow() {
        System.out.println("ëƒì˜¹");
    }


    void emoji() {
        System.out.println("ğŸ˜»");
    }
}
```

```java
public interface Visitor {
    void visit(Dog dog);
    void visit(Cat cat);
}

public class SoundVisitor implements Visitor {
    @Override
    public void visit(Dog dog) {
        dog.bark();
    }

    @Override
    public void visit(Cat cat) {
        cat.meow();
    }
}

public class EmojiVisitor implements Visitor {
    @Override
    public void visit(Dog dog) {
        dog.emoji();
    }

    @Override
    public void visit(Cat cat) {
        cat.emoji();
    }
}
```

```java
public class Zoo {
    private List<Animal> animals = new ArrayList<>();

    public void addAnimal(Animal animal) {
        animals.add(animal);
    }

    public void performOperations(Visitor visitor) {
        animals.forEach(animal -> animal.accept(visitor));
    }
}
```

```java
Zoo zoo = new Zoo();
zoo.addAnimal(new Dog());
zoo.addAnimal(new Cat());

Visitor soundVisitor = new SoundVisitor();

zoo.performOperations(soundVisitor);
// ë©ë©
// ëƒì˜¹

Visitor emojiVisitor = new EmojiVisitor();

zoo.performOperations(emojiVisitor);
// ğŸ¶
// ğŸ˜»
```

## íŒ¨í„´ ë§¤ì¹­ì˜ í˜

- ìë°”ëŠ” íŒ¨í„´ ë§¤ì¹­ì„ ì§€ì›í•˜ì§€ ì•ŠìŒ

```scala
def simplifyExpression(expr: Expr): Expr = expr match {
  case BinOp("+", e, Number(0)) => e
  // ë”í•˜ê¸° ì—°ì‚° â• ì˜¤ë¥¸ìª½ í”¼ì—°ì‚°ìê°€ 0 â¡ï¸ ì™¼ìª½ í”¼ì—°ì‚°ì eë¡œ ë‹¨ìˆœí™”
  case BinOp("*", e, Number(1)) => e
  case BinOp("/", e, Number(1)) => e
  case _ => expr // ìœ„ì˜ ê²½ìš°ì— í•´ë‹¹í•˜ì§€ ì•Šìœ¼ë©´ ì›ë˜ í‘œí˜„ì‹ ë°˜í™˜
}
```

- íŒ¨í„´ ë§¤ì¹­ì„ ì§€ì›í•˜ëŠ” ì–¸ì–´ëŠ” ì»¤ë‹¤ë€ swtichë¬¸ì´ë‚˜ if-then-else ë¬¸ì„ í”¼í•  ìˆ˜ ìˆë‹¤

## ìë°”ë¡œ íŒ¨í„´ ë§¤ì¹­ í‰ë‚´ ë‚´ê¸°

```java
public class Expr {
}

public interface TriFunctions<S, T, U, R> {
    R apply(S s, T t, U u);
}

public class BinOp extends Expr {
    String opname;
    Expr left, right;

    public BinOp(String opname, Expr left, Expr right) {
        this.opname = opname;
        this.left = left;
        this.right = right;
    }

    @Override
    public String toString() {
        return "(" + left + " " + opname + " " + right + ")";
    }
}

public class Number extends Expr {
    int val;

    public Number(int val) {
        this.val = val;
    }

    @Override
    public String toString() {
        return "" + val;
    }
}
```

```java
public static <T> T patternMatchExpr(Expr e,
                              TriFunctions<String, Expr, Expr, T> binopcase,
                              Function<Integer, T> numCase,
                              Supplier<T> defaultCase) {
    if (e instanceof BinOp) {
        return binopcase.apply(((BinOp) e).opname, ((BinOp) e).left, ((BinOp) e).right);
    }
    if (e instanceof Number) {
        return numCase.apply(((Number) e).val);
    }
    return defaultCase.get();
}
```

```java
public static Expr simplify(Expr e) {
    // BinOp í‘œí˜„ì‹ ì²˜ë¦¬
    TriFunctions<String, Expr, Expr, Expr> binopcase =
            (opname, left, right) -> {
        if ("+".equals(opname)) {
            if (left instanceof Number && ((Number) left).val == 0) {
                return right;
            }
            if (right instanceof Number && ((Number) right).val == 0) {
                return left;
            }
        }
        if ("*".equals(opname)) {
            if (left instanceof Number && ((Number) left).val == 1) {
                return right;
            }
            if (right instanceof Number && ((Number) right).val == 1) {
                return left;
            }
        }
        return new BinOp(opname, left, right);
    };
    Function<Integer, Expr> numcase = Number::new; // ìˆ«ì ì²˜ë¦¬
    Supplier<Expr> defaultcase = () -> new Number(0); // ìˆ˜ì‹ ì¸ì‹í•  ìˆ˜ ì—†ì„ ë•Œ ê¸°ë³¸ ì²˜ë¦¬

    return patternMatchExpr(e, binopcase, numcase, defaultcase);
}
```

```java
Expr e = new BinOp("+", new Number(5), new Number(0));
Expr match = simplify(e);
System.out.println(match); // 5
```

# ê¸°íƒ€ ì •ë³´

## ìºì‹± ë˜ëŠ” ê¸°ì–µí™”

- ì¬ê·€ì ìœ¼ë¡œ íƒìƒ‰ â¡ï¸ ê³„ì‚° ë¹„ìš©ì´ ë¹„ì‹¸ë‹¤
- ê°™ì€ ê³„ì‚°ì„ ë°˜ë³µì ìœ¼ë¡œ ìˆ˜í–‰
- â¡ï¸ ì°¸ì¡° íˆ¬ëª…ì„±ì´ ìœ ì§€ëœë‹¤ë©´, `ê¸°ì–µí™”(memorization)`
  - ë©”ì„œë“œì— ë˜í¼ë¡œ ìºì‹œ(HashMap ê°™ì€) ì¶”ê°€í•˜ëŠ” ê¸°ë²•
  - ë˜í¼ê°€ í˜¸ì¶œë˜ë©´ ì¸ìˆ˜, ê²°ê³¼ ìŒì´ ìºì‹œì— ì¡´ì¬í•˜ëŠ”ì§€ ë¨¼ì € í™•ì¸
  - â¡ï¸ ìºì‹œì— ê°’ì´ ì¡´ì¬í•˜ë©´ ì €ì¥ëœ ê°’ì„ ì¦‰ì‹œ ë°˜í™˜
  - â¡ï¸ ê°’ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´, ê²°ê³¼ë¥¼ ê³„ì‚°í•œ ë‹¤ìŒ ìƒˆë¡œìš´ ì¸ìˆ˜, ê²°ê³¼ ìŒì„ ìºì‹œì— ì €ì¥í•˜ê³  ê°’ì„ ë°˜í™˜

```java
final Map<Range, Integer> numberOfNodes = new HashMap<>();

public Integer computeNumberOfNodesUsingCache(Range range) {
    return numberOfNodes.computeIfAbsent(range,
            this::computeNumberOfNodes);
}
// computeNumberOfNodesê°€ ì°¸ì¡° íˆ¬ëª…í•˜ë‹¤ë©´,
// computeNumberOfNodesUsingCacheë„ ì°¸ì¡° íˆ¬ëª…ì„±ì„ ê°€ì§
```

## 'ê°™ì€ ê°ì²´ë¥¼ ë°˜í™˜í•¨'ì€ ë¬´ì—‡ì„ ì˜ë¯¸í•˜ëŠ”ê°€?

- `ì°¸ì¡° íˆ¬ëª…ì„±` : ì¸ìˆ˜ê°€ ê°™ë‹¤ë©´ ê²°ê³¼ë„ ê°™ì•„ì•¼ í•œë‹¤ëŠ” ê·œì¹™ì„ ë§Œì¡±í•¨
- í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” ë°ì´í„°ê°€ ë³€ê²½ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ê°™ë‹¤ëŠ” ì˜ë¯¸ëŠ” ==(ì°¸ì¡°ê°€ ê°™ìŒ)ì´ ì•„ë‹ˆë¼ êµ¬ì¡°ì ì¸ ê°’ì´ ê°™ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤

## ì½¤ë¹„ë„¤ì´í„°

- ë‘ í•¨ìˆ˜ë¥¼ ì¸ìˆ˜ë¡œ ë°›ì•„ ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” ë“± í•¨ìˆ˜ë¥¼ ì¡°í•©í•˜ëŠ” ê¸°ëŠ¥
- CompletableFuture í´ë˜ìŠ¤ì˜ thenCombine ë©”ì„œë“œ

```java
static <A, B, C>Function<A, C> compose(Function<B, C> g, Function<A, B> f) {
    return x -> g.apply(f.apply(x));
    // fì˜ ê¸°ëŠ¥ì„ ì ìš©í•œ ë‹¤ìŒ gì˜ ê¸°ëŠ¥ì„ ì ìš©í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë°˜í™˜
}

static <A> Function<A, A> repeat(int n, Function<A, A> f) {
    return n == 0
            ? x -> x // nì´ 0ì´ë©´ ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ
            : compose(f, repeat(n-1, f));
}
```

```java
System.out.println(repeat(3, (Integer x) -> 2 * x).apply(10)); // 80
```

# 설계 품질과 트레이드오프

- 협력 : 애플리케이션의 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용
- 책임 : 객체가 다른 객체와 협력하기 위해 수행하는 행동
- 역할 : 대체 가능한 책임의 집합

> 책임이 객체지향 애플리케이션 전체의 품질을 결정한다.

> 합리적인 설계란 합리적인 비용 안에서 변결을 수용할 수 있는 구조를 만드는 것이다.

## 캡슐화

> 변경될 수 있는 어떤 것이라도 감춘다.

- 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류
- 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서다.
  - 구현 : 나중에 변경될 가능성이 높은 어떤 것
  - 인터페이스 : 상대적으로 안정적인 부분
- 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스만 의존하도록 관계를 조절
- 변경될 수 있는 어떤 것이라도 캡슐화해야 한다.
- 유지보수성이 목표
  - 두려움 없이, 주저함 없이, 저항감 없이 코드를 변경할 수 있는 능력

## 응집도와 결합도

- `응집도`: 모듈에 포함된 내부 요소들이 연관돼 있는 정도
  - 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 높은 응집도를 가진다.
  - 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지
- `결합도`: 의존성의 정도 / 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도
  - 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지

> 변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도

- 응집도가 높을수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다.
- 클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.
  - `인터페이스에 대해 프로그래밍하라`

> 캡슐화의 정도가 응집도와 결합도에 영향을 미친다.

---

- 데이터 중심 설계는 캡슐화를 위반하고 객체의 내부 구현을 인터페이스의 일부로 만든다.
- 책임 중심 설계는 내부 구현을 안정적인 인터페이스 뒤로 캡슐화한다.
- 접근자와 수정자 메서드는 객체 내부 상태에 대한 어떤 정보도 캡슐화하지 못한다.

---

## 단일 책임 원칙(Single Responsibility Principle, SRP)

- 클래스는 단 한 가지의 변경 이유만 가져야 한다.
- `책임` == `변경의 이유`

---

- 객체에게 의미 있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드다.
- 속성의 가시성을 private로 설정했다고 해도 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 캡슐화를 위반하는 것이다.
- 코드 중복은 악의 근원이다.
- 인스턴스 변수의 존재 사실을 인터페이스를 통해 외부에 노출 ❌
- 객체는 단순한 데이터 제공자가 아니다.
- 객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다.

```markdown
- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 수행하는 오퍼레이션은 무엇인가?
```

> 내부 구현의 변경이 외부로 퍼져나가는 `파급 효과(ripple effect)`는 캡슐화가 부족하다는 명백한 증거다.

- 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다.

# 단위 테스트의 목표

- 테스트에 드는 노력을 가능한 한 줄이고 그에 따르는 이득을 최대화해야 한다.

> 좋은 테스트와 좋지 않은 테스트의 차이는 취향이나 개인적인 선호도의 문제가 아니라 현재 작업 중인 중대한 프로젝트의 성패를 가르는 문제다.

- 노력 대비 최대의 이익을 끌어내는 방식으로 단위 테스트를 수행한다.
- 테스트가 없는 프로젝트의 경우 시작은 유리하지만, 이내 진척이 없을 정도로 느려진다.
- `소프트웨어 엔트로피(software entropy)`
- 테스트는 안전망 역할을 하며, 대부분의 회귀(특정 사건 후에 기능이 의도한 대로 작동하지 않는 경우)에 대한 보험을 제공하는 도구
- 고품질 테스트만이 테스트 스위트에 남을 만한 테스트 유형이다.
- `코드는 자산이 아니라 책임이다.`
  - 코드가 더 많아질수록, 소프트웨어 내의 잠재적인 버그에 노출되는 표면적이 더 넓어지고 프로젝트 유지비가 증가한다.
- 커버리지 지표는 테스트 스위트 품질을 효과적으로 측정하는 데 사용될 수 없다.
  - 커버리지 지표는 괜찮은 부정 지표이지만 좋지 않은 긍정 지표다.

## 코드 커버리지

- 코드 커버리지(테스트 커버리지) = 제품 코드 라인 수 / 전체 라인 수
- 코드가 작을수록 테스트 커버리지 지표는 더 좋아짐 ➡️ 원래 라인 수만 처리하기 때문이다.
  - 코드를 더 작게 해도 테스트 스위트의 가치나 기반 코드베이스의 유지 보수성이 변경되지 않는다.

## 분기 커버리지

- 코드 커버리지보다 더 정확한 결과 제공
- if 문과 switch 문과 같은 제어 구조에 중점을 둔다.
- 테스트 스위트 내 하나 이상의 테스트가 통과하는 제어 구조의 수
- 분기 커버리지 = 통과 분기 / 전체 분기 수

### 커버리지 지표의 문제점

- 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다.
  - 검증이 없는 테스트는 언제나 통과한다.
- 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.
  - 테스트에서 모든 예외 상황을 다루는지 확인할 방법이 없다.
  - 지표로는 단위 테스트가 얼마나 좋은지 나쁜지를 판단할 수 없다.

> 커버리지 지표를 보는 가장 좋은 방법은 지표 그 자체로 보는 것이며, 목표로 여겨서는 안 된다.

#### 커버리지 숫자가 낮으면 문제 징후라 할 수 있다. 그러나 높은 숫자도 별 의미는 없다. 코드 커버리지를 측정하는 것은 품질 테스트 스위트로 가는 첫걸음일 뿐이다.

## 성공적인 테스트 스위트의 특성

- 개발 주기에 통합돼 있다.
  - 코드가 변경될 때마다 아무리 작은 것이라도 실행해야 한다.
- 코드 베이스에서 가장 중요한 부분만을 대상으로 한다.
  - 시스템의 가장 중요한 부분에 노력을 기울이고, 다른 부분은 간략하게 또는 간접적으로 검증하는 것이 좋다.
  - 비즈니스 로직 테스트가 시간 투자 대비 최고의 수익을 낼 수 있다.
  - 다른 부분 : 인프라 코드, 데이터베이스나 서드파티 시스템과 같은 외부 서비스 및 종속성, 모든 것을 하나로 묶는 코드
- ⭐️ 최소한의 유지비로 최대의 가치를 끌어낸다.
  - 가치 있는 테스트(➕ 가치가 낮은 테스트) 식별하기
  - 가치 있는 테스트 작성하기
